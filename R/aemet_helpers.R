#' Create the path elements for AEMET API
#'
#' Path vectors for AEMET API to use with httr::GET
#'
#' @param api_options Option list as generated by \link{\code{aemet_options}}
#'
#' @noRd
.create_aemet_path <- function(api_options) {

  # we need the resolution to create the corresponding path
  resolution <- api_options$resolution
  # we need to transform the dates to the character string specific format for the AEMET path.
  # We will use a stamp function:
  aemet_stamp <- lubridate::stamp("2020-12-25T00:00:00UTC", orders = "YOmdHMS", quiet = TRUE)

  # current day
  if (resolution == 'current_day') {
    return(c('opendata', 'api', 'observacion', 'convencional', 'todas'))
  }

  # daily
  if (resolution == 'daily') {
    return(
      c(
        'opendata', 'api', 'valores', 'climatologicos', 'diarios', 'datos',
        'fechaini', aemet_stamp(api_options$start_date),
        'fechafin', aemet_stamp(api_options$end_date),
        'todasestaciones'
      )
    )
  }

  # monthly
  # monthly API does not work for now
  # if (resolution == 'monthly') {
  #   # issue a warning if more than one station is provided
  #   if (length(api_options$stations) > 1) {
  #     warning(
  #       "AEMET API for monthly aggregated values only accepts one station per query.\n",
  #       "Only the first station provided will be used: ", api_options$stations[1]
  #     )
  #   }
  #
  #   return(
  #     c(
  #       'opendata', 'api', 'valores', 'climatologicos', 'mensualesanuales', 'datos',
  #       'anioini', lubridate::year(api_options$start_date), 'aniofin', lubridate::year(api_options$end_date),
  #       'estacion', api_options$stations[1]
  #     )
  #   )
  # }

  # not recognised resolution
  stop(
    api_options$resolution,
    " is not a valid temporal resolution for AEMET. Please see aemet_options help for more information"
  )
}

#' Get info for the aemet stations
#'
#' Get info for the aemet stations
#'
#' @noRd

.get_info_aemet <- function(api_options) {
  # path
  path_resolution <- c(
    'opendata', 'api', 'valores', 'climatologicos', 'inventarioestaciones', 'todasestaciones'
  )

  api_response <- httr::GET(
    "https://opendata.aemet.es",
    httr::add_headers(api_key = api_options$api_key),
    path = path_resolution,
    httr::user_agent('https://github.com/emf-creaf/meteospain')
  )

  if (api_response$status_code == 404) {
    stop("Unable to connect to AEMET API at ", api_response$url)
  }

  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))

  if (response_content$estado != 200) {
    stop("AEMET API returned no data:\n", response_content$descripcion)
  }

  stations_info <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$datos, httr::user_agent('https://github.com/emf-creaf/meteospain')),
      as = 'text', encoding = 'ISO-8859-15'
    ))

  stations_info %>%
    dplyr::as_tibble() %>%
    dplyr::select(
      station_id = .data$indicativo, station_name = .data$nombre, altitude = .data$altitud,
      latitude = .data$latitud, longitude = .data$longitud
    ) %>%
    dplyr::mutate(
      altitude = as.numeric(stringr::str_replace_all(.data$altitude, ',', '.')),
      altitude = units::set_units(.data$altitude, "m"),
      latitude = dplyr::if_else(
        stringr::str_detect(.data$latitude, 'S'),
        -as.numeric(stringr::str_remove_all(.data$latitude, '[A-Za-z]'))/10000,
        as.numeric(stringr::str_remove_all(.data$latitude, '[A-Za-z]'))/10000
      ),
      longitude = dplyr::if_else(
        stringr::str_detect(.data$longitude, 'W'),
        -as.numeric(stringr::str_remove_all(.data$longitude, '[A-Za-z]'))/10000,
        as.numeric(stringr::str_remove_all(.data$longitude, '[A-Za-z]'))/10000
      )
    ) %>%
    sf::st_as_sf(coords = c('longitude', 'latitude'), crs = 4326)

}

#' Get data from AEMET
#'
#' Get data from AEMET service
#'
#' For current_day and daily, there is no need of supply the stations_id in the query,
#' as the data is not so big. So, in case of stations provided, we can filter later, after getting
#' the data. This also has the advantage of using only one query, reducing the probability of reaching
#' the API limit per minute or total.
#'
#' @param api_options Option list as generated by \link{\code{aemet_options}}
#'
#' @noRd
.get_data_aemet <- function(api_options) {
  # GET ------------------------------------------------------------------------
  # create api path
  path_resolution <- .create_aemet_path(api_options)
  # get the api response
  api_response <- httr::GET(
    "https://opendata.aemet.es",
    httr::add_headers(api_key = api_options$api_key),
    path = path_resolution,
    httr::user_agent('https://github.com/emf-creaf/meteospain')
  )

  # Status check ------------------------------------------------------------------------------------------
  # now we need to check the status of the response (general status), and the status of the AEMET (specific
  # query status). They can differ, as you can reach succesfully AEMET API (200) but the response can be
  # empty due to errors in the dates or stations (404) or simply the api key is incorrect (xxx).
  if (api_response$status_code == 404) {
    stop("Unable to connect to AEMET API at ", api_response$url)
  }
  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))
  if (response_content$estado != 200) {
    stop("AEMET API returned no data:\n", response_content$descripcion)
  }


  # Stations data and metadata GET steps ------------------------------------------------------------------
  # And now the data. This is somewhat redundant, but AEMET API does not return the data directly, but a
  # temporary link to the data (it will expire in a few minutes). So we need to repeat the steps again, but
  # this time with a trick. AEMET data seems to be codified in ISO-8859-15, but this generates errors in
  # retrieving the data, so we need to supply the correct encoding.
  stations_data <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$datos, httr::user_agent('https://github.com/emf-creaf/meteospain')),
      as = 'text', encoding = 'ISO-8859-15'
    ))
  # We also need the metadata to show the copyright, and the legal note
  request_metadata <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$metadatos, httr::user_agent('https://github.com/emf-creaf/meteospain')),
      as = 'text', encoding = 'ISO-8859-15'
    ))
  # We also need the stations info
  stations_info <- .get_info_aemet(api_options)

  # Filter expression for stations ------------------------------------------------------------------------
  # In case stations were supplied, we need also to filter them
  filter_expression <- TRUE
  # update filter if there is stations supplied
  if (!rlang::is_null(api_options$stations)) {
    filter_expression <- switch(
      api_options$resolution,
      'current_day' = rlang::expr(.data$idema %in% api_options$stations),
      'daily' = rlang::expr(.data$indicativo %in% api_options$stations)
    )
  }

  # Resolution specific carpentry -------------------------------------------------------------------------
  # Now, current day and daily have differences, in the names of the variables and also
  # in the need to join the stations data to offer coords. We can branch the code with ifs, repeating the
  # common steps in the data carpentry or we can create the specific functions and have only one common pipe.
  # The latter will simplify adding monthly in the future, so lets do it:
  resolution_specific_carpentry <- switch(
    api_options$resolution,
    'current_day' = function(.data) {
      .data %>%
        dplyr::select(
          timestamp = .data$fint, station_id = .data$idema, station_name = .data$ubi,
          altitude = .data$alt,
          temperature = .data$ta,
          min_temperature = .data$tamin,
          max_temperature = .data$tamax,
          relative_humidity = .data$hr,
          precipitation = .data$prec,
          wind_speed = .data$vv,
          wind_direction = .data$dv,
          longitude = .data$lon, latitude = .data$lat,
        ) %>%
        # units
        dplyr::mutate(
          altitude = units::set_units(.data$altitude, "m"),
          temperature = units::set_units(.data$temperature, "degree_C"),
          min_temperature = units::set_units(.data$min_temperature, "degree_C"),
          max_temperature = units::set_units(.data$max_temperature, "degree_C"),
          relative_humidity = units::set_units(.data$relative_humidity, "%"),
          precipitation = units::set_units(.data$precipitation, "L/m^2"),
          wind_speed = units::set_units(.data$wind_speed, "m/s"),
          wind_direction = units::set_units(.data$wind_direction, "degree")
        ) %>%
        sf::st_as_sf(coords = c('longitude', 'latitude'), crs = 4326)
    },
    'daily' = function(.data) {
      .data %>%
        dplyr::select(
          timestamp = .data$fecha,
          station_id = .data$indicativo, station_name = .data$nombre, station_province = .data$provincia,
          mean_temperature = .data$tmed,
          min_temperature = .data$tmin,
          max_temperature = .data$tmax,
          precipitation = .data$prec,
          mean_wind_speed = .data$velmedia,
          # wind_direction = .data$dir,
          insolation = .data$sol
        ) %>%
        # variables are characters, with "," as decimal point, so....
        dplyr::mutate(
          mean_temperature = as.numeric(stringr::str_replace_all(.data$mean_temperature, ',', '.')),
          min_temperature = as.numeric(stringr::str_replace_all(.data$min_temperature, ',', '.')),
          max_temperature = as.numeric(stringr::str_replace_all(.data$max_temperature, ',', '.')),
          precipitation = suppressWarnings(as.numeric(stringr::str_replace_all(.data$precipitation, ',', '.'))),
          mean_wind_speed = as.numeric(stringr::str_replace_all(.data$mean_wind_speed, ',', '.')),
          # wind_direction = as.numeric(stringr::str_replace_all(.data$wind_direction, ',', '.')),
          insolation = as.numeric(stringr::str_replace_all(.data$insolation, ',', '.')),
          # and set the units also
          mean_temperature = units::set_units(.data$mean_temperature, "degree_C"),
          min_temperature = units::set_units(.data$min_temperature, "degree_C"),
          max_temperature = units::set_units(.data$max_temperature, "degree_C"),
          precipitation = units::set_units(.data$precipitation, "L/m^2"),
          mean_wind_speed = units::set_units(.data$mean_wind_speed, "m/s"),
          # wind_direction = units::set_units(.data$wind_direction, degree),
          insolation = units::set_units(.data$insolation, "h")
        ) %>%
        dplyr::left_join(stations_info, by = c('station_id', 'station_name'))
    }
  )

  # NOTE::
  # AEMET monthly seems to be impossible to reach from R, I spent 3 days trying every option
  # I found and nothing, so I remove it from now, to wait for a solution.
  # NOTE: It also doesn't work with the python example in their webpage, so...
  # I tried to communicate with them, No solution offered :(

  # Data transformation -----------------------------------------------------------------------------------
  res <- stations_data %>%
    dplyr::as_tibble() %>%
    # remove unwanted stations
    dplyr::filter(!! filter_expression) %>%
    # apply the resolution-specific transformations
    resolution_specific_carpentry() %>%
    # arrange data
    dplyr::arrange(.data$timestamp, .data$station_id) %>%
    # ensure we have an sf
    sf::st_as_sf() %>%
    # reorder variables to be consistent among all services
    dplyr::relocate(
      dplyr::contains('timestamp'),
      dplyr::contains('station'),
      dplyr::contains('altitude'),
      dplyr::contains('temperature'),
      dplyr::contains('humidity'),
      dplyr::contains('precipitation'),
      dplyr::contains('wind'),
      dplyr::contains('sol'),
      .data$geometry
    )


  # Check stations ----------------------------------------------------------------------------------------
  if ((!is.null(api_options$stations)) & nrow(res) < 1) {
    stop(
      "Station(s) provided have no data for the dates selected.\n",
      "Available stations with data for the actual query are:\n",
      paste0(c(unique(stations_data$indicativo), unique(stations_data$idema)), collapse = ', ')
    )
  }

  # Check request limit -----------------------------------------------------------------------------------
  # we need to check if we are reaching the request limit of the API, and if we are near, take a rest.
  # If remaining-request-count goes down 100 it can broke, not always with a 426 error, so instead of checking
  # the error, check the count. Also, if we let it go down 106, next request could reach the limit (is not
  # 1 per GET, as we need to GET the results again and GET the metadata so we can join), so we specifiy the
  # limit at 106 to cooldown for 60 seconds.
  if (as.numeric(api_response$headers$`remaining-request-count`) <= 106) {
    message("Reaching the API request limit per minute, taking a cooldown of 60 seconds to reset.")
    Sys.sleep(60)
  }

  # Copyright message -------------------------------------------------------------------------------------
  message(copyright_style(request_metadata$copyright), '\n', legal_note_style(request_metadata$notaLegal))

  # Return ------------------------------------------------------------------------------------------------
  return(res)
}
