#' Create the path elements for AEMET API
#'
#' Path vectors for AEMET API to use with httr::GET
#'
#' @param api_options Option list as generated by \link{\code{aemet_options}}
#'
#' @noRd
.create_aemet_path <- function(api_options) {

  # we need the resolution to create the corresponding path
  resolution <- api_options$resolution
  # we need to transform the dates to the character string especific format for the AEMET path.
  # We will use a stamp function:
  aemet_stamp <- lubridate::stamp("2020-12-25T00:00:00UTC", orders = "YOmdHMS", quiet = TRUE)

  # current day
  if (resolution == 'current_day') {
    return(c('opendata', 'api', 'observacion', 'convencional', 'todas'))
  }

  # hourly and daily (are the same query, we aggregate daily later)
  if (resolution == 'daily') {
    return(
      c(
        'opendata', 'api', 'valores', 'climatologicos', 'diarios', 'datos',
        'fechaini', aemet_stamp(api_options$start_date),
        'fechafin', aemet_stamp(api_options$end_date),
        'todasestaciones'
      )
    )
  }

  # monthly
  # monthly API does not work for now
  # if (resolution == 'monthly') {
  #   # issue a warning if more than one station is provided
  #   if (length(api_options$stations) > 1) {
  #     warning(
  #       "AEMET API for monthly aggregated values only accepts one station per query.\n",
  #       "Only the first station provided will be used: ", api_options$stations[1]
  #     )
  #   }
  #
  #   return(
  #     c(
  #       'opendata', 'api', 'valores', 'climatologicos', 'mensualesanuales', 'datos',
  #       'anioini', lubridate::year(api_options$start_date), 'aniofin', lubridate::year(api_options$end_date),
  #       'estacion', api_options$stations[1]
  #     )
  #   )
  # }

  # not recognised resolution
  stop(
    api_options$resolution,
    " is not a valid temporal resolution for AEMET. Please see aemet_options help for more information"
  )
}


#' Get data from AEMET
#'
#' Get data from AEMET service
#'
#' For current_day, hourly and daily, there is no need of supply the stations_id in the query,
#' as the data is not so big, so in case of stations provided, we can filter later, after getting
#' the data. This also has the advantage of using only one query, reducing the probability of reaching
#' the API limit per minute or total. For monthly, only one station is allowed in the API (there is no
#' all stations path), so a warning must be ensued to the user, and only the first station will be used
#'
#' @param api_options Option list as generated by \link{\code{aemet_options}}
#'
#' @noRd
.get_data_aemet <- function(api_options) {
  # Common part to all resolutions ------------------------------------------------------------------------

  # get api path
  path_resolution <- .create_aemet_path(api_options)
  # get the api response
  api_response <- httr::GET(
    "https://opendata.aemet.es",
    httr::add_headers(api_key = api_options$api_key),
    path = path_resolution
  )
  # now we need to check the status of the response (general status), and the status of the AEMET (specific
  # query status). They can differ, as you can reach succesfully AEMET API (200) but the response can be
  # empty due to errors in the dates or stations (404) or simply the api key is incorrect (xxx).
  if (api_response$status_code == 404) {
    stop("Unable to connect to AEMET API at ", api_response$url)
  }
  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))
  if (response_content$estado != 200) {
    stop("AEMET API returned no data:\n", response_content$descripcion)
  }
  # And now the data. This is somewhat redundant, but AEMET API does not return the data directly, but a
  # temporary link to the data (it will expire in a few minutes). So we need to repeat the steps again, but
  # this time with a trick. AEMET data seems to be codified in ISO-8859-15, but this generates errors in
  # retrieving the data, so we need to supply the correct encoding.
  stations_data <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$datos), as = 'text', encoding = 'ISO-8859-15'
    ))
  # Also, in case stations were supplied, we need also to filter them
  filter_expression <- TRUE

  # aemet current day -------------------------------------------------------------------------------------
  if (api_options$resolution == 'current_day') {
    # update filter if there is stations supplied
    if (!rlang::is_null(api_options$stations)) {
      filter_expression <- rlang::expr(idema %in% api_options$stations)
    }

    res <- stations_data %>%
      dplyr::as_tibble() %>%
      dplyr::filter(!! filter_expression) %>%
      dplyr::select(
        timestamp = fint, station_id = idema, station_name = ubi,
        altitude = alt,
        temperature = ta,
        min_temperature = tamin,
        max_temperature = tamax,
        precipitation = prec,
        relative_humidity = hr,
        wind_speed = vv,
        wind_direction = dv,
        longitude = lon, latitude = lat,
      ) %>%
      # units
      dplyr::mutate(
        altitude = units::set_units(altitude, m),
        temperature = units::set_units(temperature, degree_C),
        min_temperature = units::set_units(min_temperature, degree_C),
        max_temperature = units::set_units(max_temperature, degree_C),
        precipitation = units::set_units(precipitation, mm),
        relative_humidity = units::set_units(relative_humidity, `%`),
        wind_speed = units::set_units(wind_speed, m/s),
        wind_direction = units::set_units(wind_direction, degree)
      ) %>%
      sf::st_as_sf(coords = c('longitude', 'latitude'), crs = 4326)
  }

  # aemet daily -------------------------------------------------------------------------------------------
  if (api_options$resolution == 'daily') {
    # daily data has not info about the coordinates of the stations, we need to get that with the
    # stations info.
    stations_info <- .get_info_aemet(api_options)
    # update filter if there are stations supplied
    if (!rlang::is_null(api_options$stations)) {
      filter_expression <- rlang::expr(indicativo %in% api_options$stations)
    }
    # data
    res <- stations_data %>%
      dplyr::as_tibble() %>%
      dplyr::filter(!! filter_expression) %>%
      dplyr::select(
        timestamp = fecha, station_id = indicativo, station_name = nombre, station_province = provincia,
        mean_temperature = tmed,
        min_temperature = tmin,
        max_temperature = tmax,
        precipitation = prec,
        mean_wind_speed = velmedia,
        # wind_direction = dir,
        insolation = sol
      ) %>%
      # variables are characters, with "," as decimal point, so....
      dplyr::mutate(
        mean_temperature = as.numeric(stringr::str_replace_all(mean_temperature, ',', '.')),
        min_temperature = as.numeric(stringr::str_replace_all(min_temperature, ',', '.')),
        max_temperature = as.numeric(stringr::str_replace_all(max_temperature, ',', '.')),
        precipitation = suppressWarnings(as.numeric(stringr::str_replace_all(precipitation, ',', '.'))),
        mean_wind_speed = as.numeric(stringr::str_replace_all(mean_wind_speed, ',', '.')),
        # wind_direction = as.numeric(stringr::str_replace_all(wind_direction, ',', '.')),
        insolation = as.numeric(stringr::str_replace_all(insolation, ',', '.')),
        # and set the units also
        mean_temperature = units::set_units(mean_temperature, degree_C),
        min_temperature = units::set_units(min_temperature, degree_C),
        max_temperature = units::set_units(max_temperature, degree_C),
        precipitation = units::set_units(precipitation, mm),
        mean_wind_speed = units::set_units(mean_wind_speed, m/s),
        # wind_direction = units::set_units(wind_direction, degree),
        insolation = units::set_units(insolation, h)
      ) %>%
      dplyr::left_join(stations_info, by = c('station_id', 'station_name')) %>%
      sf::st_as_sf()
  }

  # aemet monthly -----------------------------------------------------------------------------------------
  # AEMET monthly seems to be impossible to reach from R, I spent 3 days trying every option
  # I found and nothing, so I remove it from now, to wait for a solution.
  # NOTE: It also doesn't work with the python example in their webpage, so...
  # I tried to communicate with them, no answer yet.
  # if (api_options$resolution == 'monthly') {
  #
  # }


  # Check stations ----------------------------------------------------------------------------------------
  if ((!is.null(api_options$stations)) & nrow(res) < 1) {
    stop(
      "Station(s) provided have no data for the dates selected.\n",
      "Available stations with data for the actual query are:\n",
      paste0(c(unique(stations_data$indicativo), unique(stations_data$idema)), collapse = ', ')
    )
  }

  return(res)
}

#' Get info for the aemet stations
#'
#' Get info for the aemet stations
#'
#' @noRd

.get_info_aemet <- function(api_options) {
  # path
  path_resolution <- c(
    'opendata', 'api', 'valores', 'climatologicos', 'inventarioestaciones', 'todasestaciones'
  )

  api_response <- httr::GET(
    "https://opendata.aemet.es",
    httr::add_headers(api_key = api_options$api_key),
    path = path_resolution
  )

  if (api_response$status_code != 200) {
    stop("Unable to connect to AEMET API at ", api_response$url)
  }

  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))

  if (response_content$estado != 200) {
    stop("AEMET API returned no data:\n", response_content$descripcion)
  }

  stations_info <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$datos), as = 'text', encoding = 'ISO-8859-15'
    ))

  stations_info_metadata <-
    jsonlite::fromJSON(httr::content(
      httr::GET(response_content$metadatos), as = 'text', encoding = 'ISO-8859-15'
    ))

  stations_info %>%
    dplyr::as_tibble() %>%
    dplyr::select(
      station_id = indicativo, station_name = nombre, altitude = altitud,
      latitude = latitud, longitude = longitud
    ) %>%
    dplyr::mutate(
      altitude = as.numeric(stringr::str_replace_all(altitude, ',', '.')),
      altitude = units::set_units(altitude, m),
      latitude = dplyr::if_else(
        stringr::str_detect(latitude, 'S'),
        -as.numeric(stringr::str_remove_all(latitude, '[A-Za-z]'))/10000,
        as.numeric(stringr::str_remove_all(latitude, '[A-Za-z]'))/10000
      ),
      longitude = dplyr::if_else(
        stringr::str_detect(longitude, 'W'),
        -as.numeric(stringr::str_remove_all(longitude, '[A-Za-z]'))/10000,
        as.numeric(stringr::str_remove_all(longitude, '[A-Za-z]'))/10000
      )
    ) %>%
    sf::st_as_sf(coords = c('longitude', 'latitude'), crs = 4326)

}
