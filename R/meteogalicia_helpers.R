#' Create the path elements for MeteoGalicia API
#'
#' Path vectors for MeteoGalicia API to use with httr::GET
#'
#' @param api_options Option list as generated by \link{\code{meteogalicia_options}}
#'
#' @noRd
.create_meteogalicia_path <- function(api_options) {

  # we need the resolution to create the corresponding path
  resolution <- api_options$resolution

  ## TODO Maybe a switch here is more efficient, but we have to control for non recognised resolution.
  ## Worth to check it some time.

  # instant
  if (resolution == 'instant') {
    return(c('rss', 'observacion', 'ultimos10minEstacionsMeteo.action'))
  }

  # current day
  if (resolution == 'current_day') {
    return(c('rss', 'observacion', 'ultimosHorariosEstacions.action'))
  }

  # daily
  if (resolution == 'daily') {
    return(c('rss', 'observacion', 'datosDiariosEstacionsMeteo.action'))
  }

  # monthly
  if (resolution == 'monthly') {
    return(c('rss', 'observacion', 'datosMensuaisEstacionsMeteo.action'))
  }

  # not recognised resolution
  stop(
    api_options$resolution,
    " is not a valid temporal resolution for MeteoGalicia. Please see meteogalicia_options help for more information"
  )
}

#' Create the query element for MeteoGalicia API
#'
#' Query string for MeteoGalicia API to use with httr::GET
#'
#' MeteoGalicia allows to include queries in the link, to select dates, stations and hours in current. This
#' is more flexible than the paths in AEMET and allows to retrieve the stations desired directly in an easy
#' way.
#'
#' @param api_options Option list as generated by \link{\code{meteogalicia_options}}
#'
#' @noRd
.create_meteogalicia_query <- function(api_options) {

  # In case of dates supplied and in the corresponding resolutions, we need to transform the dates to the
  # character string specific format (dd-mm-yyyy) for the meteogalicia query
  # We will use a stamp function:
  meteogalicia_stamp <- lubridate::stamp("25/12/2001", orders = "d0mY", quiet = TRUE)

  # the first thing is the stations, as it is the common part for any resolution
  stations_query_string <- glue::glue("idEst={glue::glue_collapse(api_options$stations, sep = ',')}")

  # dates also can be done, and used if needed
  dates_query_string <- glue::glue(
    "dataIni={meteogalicia_stamp(api_options$start_date)}&dataFin={meteogalicia_stamp(api_options$end_date)}"
  )

  # now the specifics for each resolution:
  #   - instant, nothing, only the stations if any
  #   - current day, stations if any and numHoras=24
  #   - daily, stations if any, start date and end date
  #   - monthly, stations if any, start date and end date

  if (api_options$resolution == 'instant') {
    res <- .empty_string_to_null(stations_query_string)
  }
  if (api_options$resolution == 'current_day') {
    if (rlang::is_null(api_options$stations)) {
      res <- "numHoras=24"
    } else {
      res <- glue::glue("{stations_query_string}&numHoras=24")
    }
  }
  if (api_options$resolution %in% c('daily', 'monthly')) {
    if (rlang::is_null(api_options$stations)) {
      res <- dates_query_string
    } else {
      res <- glue::glue("{stations_query_string}&{dates_query_string}")
    }
  }

  return(res)
}


#' Get info for the meteogalicia stations
#'
#' Get info for the meteogalicia stations
#'
#' @noRd

.get_info_meteogalicia <- function() {
  # path
  path_resolution <- c(
    'rss', 'observacion', 'listaEstacionsMeteo.action'
  )

  # api response
  api_response <- httr::GET(
    "http://servizos.meteogalicia.es",
    path = path_resolution
  )

  # check status
  if (api_response$status_code != 200) {
    stop("Unable to connect to meteogalicia API at ", api_response$url)
  }

  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))

  # Meteogalicia returns a list, with one element called listaEstacionsMeteo, that is parsed directly to
  # a data.frame with all the info. We work with that.
  response_content$listaEstacionsMeteo %>%
    dplyr::as_tibble() %>%
    dplyr::select(
      station_id = idEstacion, station_name = estacion, station_province = provincia,
      altitude, lat, lon
    ) %>%
    dplyr::mutate(
      station_id = as.character(station_id),
      altitude = units::set_units(altitude, m)
    ) %>%
    sf::st_as_sf(coords = c('lon', 'lat'), crs = 4326)

}

#' Get data from MeteoGalicia
#'
#' Get data from MeteoGalicia service
#'
#' MeteoGalicia API, based on RSS, is very well organized. It allows to supply dates and stations as
#' query parameters, which gives a lot of flexibility and makes my life easier. All my love to MeteoGalicia!!
#'
#' @param api_options Option list as generated by \link{\code{meteogalicia_options}}
#'
#' @noRd
.get_data_meteogalicia <- function(api_options) {

  # Common part to all resolutions ------------------------------------------------------------------------

  # get api path
  path_resolution <- .create_meteogalicia_path(api_options)

  # get api query
  query_resolution <- .create_meteogalicia_query(api_options)

  # get step
  api_response <- httr::GET(
    "http://servizos.meteogalicia.es",
    path = path_resolution,
    query = query_resolution
  )

  # check status
  if (api_response$status_code != 200) {
    stop("Unable to connect to meteogalicia API at ", api_response$url)
  }

  ## Check when empty lists are returned (bad dates), when html with error is returned (bad stations)
  if (stringr::str_detect(httr::content(api_response, as = 'text'), '<html>')) {
    stop(
      "MeteoGalicia API returned an error:\n",
      stringr::str_remove_all(xml2::xml_text(httr::content(api_response)), '[\\t\\n]'),
      '\n',
      'This ususally happens when bad station ids are supplied.'
    )
  }

  # response content
  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text'))

  if (length(response_content[[1]]) < 1) {
    stop(
      "MeteoGalicia API returned no data:\n",
      "This usually happens when there is no data for the dates supplied."
    )
  }

  # meteogalicia instant ----------------------------------------------------------------------------------

  if (api_options$resolution == 'instant') {

    # MeteoGalicia returns (parsed from json) a dataframe ($listUltimos10min) with the a row for each station,
    # the id and the reading timestamp. Also a column of dataframes (listaMedidas) with a column with the
    # variables, a column with values and some metadata (units, name in galician...). So, we have a nested
    # data frame, and the inner ones are transposed. So, basically, unnest, remove metadata and pivot wide.
    res <-
      response_content$listUltimos10min %>%
      tidyr::unnest(listaMedidas) %>%
      # remove the non valid data (0 == no validated data, 3 = wrong data, 9 = data not registered)
      dplyr::filter(!lnCodigoValidacion %in% c(0, 3, 9)) %>%
      dplyr::select(-lnCodigoValidacion, -nomeParametro, -unidade) %>%
      # now, some stations can have errors in the sense of duplicated precipitation values.
      # We get the first record
      tidyr::pivot_wider(names_from = codigoParametro, values_from = valor, values_fn = dplyr::first) %>%
      dplyr::select(
        timestamp = instanteLecturaUTC, station_id = idEstacion, station_name = estacion,
        temperature = TA_AVG_1.5m,
        wind_direction = DV_AVG_2m,
        wind_speed = VV_AVG_2m,
        relative_humidity = HR_AVG_1.5m,
        precipitation = PP_SUM_1.5m,
        insolation = HSOL_SUM_1.5m,
        global_solar_radiation = RS_AVG_1.5m
      ) %>%
      dplyr::mutate(
        timestamp = lubridate::as_date(timestamp),
        station_id = as.character(station_id),
        temperature = units::set_units(temperature, degree_C),
        wind_direction = units::set_units(wind_direction, degree),
        wind_speed = units::set_units(wind_speed, m/s),
        relative_humidity = units::set_units(relative_humidity, `%`),
        precipitation = units::set_units(precipitation, L/m2),
        insolation = units::set_units(insolation, h),
        global_solar_radiation = units::set_units(global_solar_radiation, W/m2)
      ) %>%
      dplyr::left_join(.get_info_meteogalicia(), by = c('station_id', 'station_name')) %>%
      sf::st_as_sf()
  }

  # metegalicia current day -------------------------------------------------------------------------------

  if (api_options$resolution == 'current_day') {

    # For current is a double nested data frames. First the list of instants (hours), and then the list of
    # measures. So double unnest, the rest is the same except for the variables, as there are some new and
    # some that are not present

    res <-
      response_content$listHorarios %>%
      tidyr::unnest(listaInstantes) %>%
      tidyr::unnest(listaMedidas) %>%
      # remove the non valid data (0 == no validated data, 3 = wrong data, 9 = data not registered)
      dplyr::filter(!lnCodigoValidacion %in% c(0, 3, 9)) %>%
      dplyr::select(-lnCodigoValidacion, -nomeParametro, -unidade) %>%
      # now, some stations can have errors in the sense of duplicated precipitation values.
      # We get the first record
      tidyr::pivot_wider(names_from = codigoParametro, values_from = valor, values_fn = dplyr::first) %>%
      # When querying stations, it can happen that some stations lack some variables, making the further
      # select step to fail. We create missing variables and populate them with NAs to avoid this error
      .create_missing_vars(
        var_names = c(
          'TA_AVG_1.5m', 'TA_MIN_1.5m', 'TA_MAX_1.5m', 'DV_AVG_2m', 'VV_AVG_2m',
          'HR_AVG_1.5m', 'PP_SUM_1.5m', 'HSOL_SUM_1.5m'
        )
      ) %>%
      dplyr::select(
        timestamp = instanteLecturaUTC, station_id = idEstacion, station_name = estacion,
        temperature = TA_AVG_1.5m,
        min_temperature = TA_MIN_1.5m,
        max_temperature = TA_MAX_1.5m,
        wind_direction = DV_AVG_2m,
        wind_speed = VV_AVG_2m,
        relative_humidity = HR_AVG_1.5m,
        precipitation = PP_SUM_1.5m,
        insolation = HSOL_SUM_1.5m
      ) %>%
      dplyr::mutate(
        timestamp = lubridate::as_datetime(timestamp),
        station_id = as.character(station_id),
        temperature = units::set_units(temperature, degree_C),
        min_temperature = units::set_units(min_temperature, degree_C),
        max_temperature = units::set_units(max_temperature, degree_C),
        wind_direction = units::set_units(wind_direction, degree),
        wind_speed = units::set_units(wind_speed, m/s),
        relative_humidity = units::set_units(relative_humidity, `%`),
        precipitation = units::set_units(precipitation, L/m2),
        insolation = units::set_units(insolation, h)
      ) %>%
      dplyr::arrange(timestamp, station_id) %>%
      dplyr::left_join(.get_info_meteogalicia(), by = c('station_id', 'station_name')) %>%
      sf::st_as_sf()
  }


  # meteogalicia daily ------------------------------------------------------------------------------------

  if (api_options$resolution == 'daily') {

    # As in the current day, we have a double nested dataframe
    res <-
      response_content$listDatosDiarios %>%
      tidyr::unnest(listaEstacions) %>%
      tidyr::unnest(listaMedidas) %>%
      # remove the non valid data (0 == no validated data, 3 = wrong data, 9 = data not registered)
      dplyr::filter(!lnCodigoValidacion %in% c(0, 3, 9)) %>%
      dplyr::select(-lnCodigoValidacion, -nomeParametro, -unidade) %>%
      # now, some stations can have errors in the sense of duplicated precipitation values.
      # We get the first record
      tidyr::pivot_wider(names_from = codigoParametro, values_from = valor, values_fn = dplyr::first) %>%
      # When querying stations, it can happen that some stations lack some variables, making the further
      # select step to fail. We create missing variables and populate them with NAs to avoid this error
      .create_missing_vars(
        var_names = c(
          'TA_AVG_1.5m', 'TA_MIN_1.5m', 'TA_MAX_1.5m', 'DV_AVG_2m', 'VV_AVG_2m',
          'HR_AVG_1.5m', 'HR_MIN_1.5m', 'HR_MAX_1.5m', 'PP_SUM_1.5m', 'HSOL_SUM_1.5m'
        )
      ) %>%
      dplyr::select(
        timestamp = data, station_id = idEstacion, station_name = estacion, station_province = provincia,
        temperature = TA_AVG_1.5m,
        min_temperature = TA_MIN_1.5m,
        max_temperature = TA_MAX_1.5m,
        wind_direction = DV_AVG_2m,
        wind_speed = VV_AVG_2m,
        relative_humidity = HR_AVG_1.5m,
        min_relative_humidity = HR_MIN_1.5m,
        max_relative_humidity = HR_MAX_1.5m,
        precipitation = PP_SUM_1.5m,
        insolation = HSOL_SUM_1.5m
      ) %>%
      dplyr::mutate(
        timestamp = lubridate::as_date(timestamp),
        station_id = as.character(station_id),
        temperature = units::set_units(temperature, degree_C),
        min_temperature = units::set_units(min_temperature, degree_C),
        max_temperature = units::set_units(max_temperature, degree_C),
        wind_direction = units::set_units(wind_direction, degree),
        wind_speed = units::set_units(wind_speed, m/s),
        relative_humidity = units::set_units(relative_humidity, `%`),
        min_relative_humidity = units::set_units(min_relative_humidity, `%`),
        max_relative_humidity = units::set_units(max_relative_humidity, `%`),
        precipitation = units::set_units(precipitation, L/m2),
        insolation = units::set_units(insolation, h)
      ) %>%
      dplyr::arrange(timestamp, station_id) %>%
      dplyr::left_join(.get_info_meteogalicia(), by = c('station_id', 'station_name', 'station_province')) %>%
      sf::st_as_sf()

  }

  # meteogalicia monthly ----------------------------------------------------------------------------------

  if (api_options$resolution == 'monthly') {

    # As in the daily, we have a double nested dataframe
    res <-
      response_content$listDatosMensuais %>%
      tidyr::unnest(listaEstacions) %>%
      tidyr::unnest(listaMedidas) %>%
      # remove the non valid data (0 == no validated data, 3 = wrong data, 9 = data not registered)
      dplyr::filter(!lnCodigoValidacion %in% c(0, 3, 9)) %>%
      dplyr::select(-lnCodigoValidacion, -nomeParametro, -unidade) %>%
      # now, some stations can have errors in the sense of duplicated precipitation values.
      # We get the first record
      tidyr::pivot_wider(names_from = codigoParametro, values_from = valor, values_fn = dplyr::first) %>%
      # When querying stations, it can happen that some stations lack some variables, making the further
      # select step to fail. We create missing variables and populate them with NAs to avoid this error
      .create_missing_vars(
        var_names = c(
          'TA_AVG_1.5m', 'TA_MIN_1.5m', 'TA_MAX_1.5m', 'VV_AVG_2m',
          'HR_AVG_1.5m', 'PP_SUM_1.5m', 'HSOL_SUM_1.5m'
        )
      ) %>%
      dplyr::select(
        timestamp = data, station_id = idEstacion, station_name = estacion, station_province = provincia,
        temperature = TA_AVG_1.5m,
        min_temperature = TA_MIN_1.5m,
        max_temperature = TA_MAX_1.5m,
        wind_speed = VV_AVG_2m,
        relative_humidity = HR_AVG_1.5m,
        precipitation = PP_SUM_1.5m,
        insolation = HSOL_SUM_1.5m
      ) %>%
      dplyr::mutate(
        timestamp = lubridate::as_date(timestamp),
        station_id = as.character(station_id),
        temperature = units::set_units(temperature, degree_C),
        min_temperature = units::set_units(min_temperature, degree_C),
        max_temperature = units::set_units(max_temperature, degree_C),
        wind_speed = units::set_units(wind_speed, m/s),
        relative_humidity = units::set_units(relative_humidity, `%`),
        precipitation = units::set_units(precipitation, L/m2),
        insolation = units::set_units(insolation, h)
      ) %>%
      dplyr::arrange(timestamp, station_id) %>%
      dplyr::left_join(.get_info_meteogalicia(), by = c('station_id', 'station_name', 'station_province')) %>%
      sf::st_as_sf()

  }

  return(res)
}
