#' Check status and errors for MeteoCat
#'
#' Check status and erros for MeteoCat
#'
#' In the MeteoCat API errors are correctly raised and can be checked straightforward.
#'
#' @section Rationale:
#' So, the rationale is the following, a function accepting \code{...} that will be passed to
#' httr::GET, and internally checking statuses. If error, return the error code and the message.
#' In the main function, if the error returned is API limit, wait 60 seconds, if other, stop
#' and give the correct message.
#'
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Arguments for httr::GET
#'
#' @noRd
.check_status_meteocat <- function(...) {

  # GET step
  api_response <- httr::GET(...)
  response_status <- httr::status_code(api_response)

  # and now the status checks
  # 400 Bad Request: Parameters are not correct, message contains further info
  # 403 Forbidden: If message indicates Forbidden, bad api key, if the message indicates Missing authentication
  #   token means that the resource does not exists
  # 429 Too Many Request: Quota limit or request per second limit passed
  # 500 Internal Error Server: Internal error, message contains further info
  if (response_status == 400) {
    res <- list(
      status = 'Error',
      code = response_status,
      message = glue::glue(
        "Unable to obtain data from MeteoCat API: {httr::http_status(api_response)$message}"
      )
    )
    return(res)
  }

  if (response_status == 403) {
    response_message <- httr::http_status(api_response)$message

    if (stringr::str_detect(response_message, 'Forbidden')) {
      res <- list(
        status = 'Error',
        code = response_status,
        message = glue::glue(
          "Invalid API Key: {response_message}"
        )
      )
      return(res)
    } else {
      res <- list(
        status = 'Error',
        code = response_status,
        message = glue::glue(
          "Resource does not exist: {response_message}"
        )
      )
    }
  }

  # If we reach here, is because everything went well
  response_content <- jsonlite::fromJSON(httr::content(api_response, as = 'text', encoding = 'UTF-8'))
  res <- list(
    status = 'OK',
    code = response_status,
    message = "Data received",
    content = response_content
  )

  return(res)
}

#' Get variables metadata
#'
#' Variables metadata
#'
#' @param api_options Option list as generated by \link{\code{meteocat_options}}
#' @noRd
.get_variables_meteocat <- function(api_options) {

  # path
  path_resolution <- switch(
    api_options$resolution,
    'instant' = c('xema', 'v1', 'variables', 'mesurades', 'metadades'),
    'hourly' = c('xema', 'v1', 'variables', 'mesurades', 'metadades'),
    'daily' = c('xema', 'v1', 'variables', 'estadistics', 'diaris', 'metadades'),
    'monthly' = c('xema', 'v1', 'variables', 'estadistics', 'mensuals', 'metadades'),
    'yearly' = c('xema', 'v1', 'variables', 'estadistics', 'anuals', 'metadades')
  )


  # get and status check ----------------------------------------------------------------------------------
  api_status_check <- .check_status_meteocat(
    'https://api.meteo.cat',
    httr::add_headers(`x-api-key` = api_options$api_key),
    path = path_resolution,
    httr::user_agent('https://github.com/emf-creaf/meteospain')
  )

  if (api_status_check$status != 'OK') {
    # if api request limit reached, do a recursive call to the function after 60 seconds
    if (api_status_check$code == 429) {
      message(copyright_style(api_status_check$message))
      Sys.sleep(60)
      return(.get_variables_meteocat(api_options))
    } else {
      stop(api_status_check$code, ':\n', api_status_check$message)
    }
  }

  response_content <- api_status_check$content %>%
    dplyr::as_tibble()
  return(response_content)
}

#' Create the path elements for MeteoCat API
#'
#' Path vectors for MeteoCat API to use with httr::GET
#'
#' @section Dates
#' In this case as MeteoCat is capped to one date: one day for hourly, one month for daily, one year for
#' monthly and all years for yearly (no date needed). So we only use the start_date
#'
#' @section Variables
#' MeteoCat API only return one variable for all stations, so we need to iterate the desired variables. This
#' means that \code{.create_meteocat_path} should return a vector of paths for which iterate the get function.
#' Desired variables are:
#' \itemize{
#'   \item{instant & hourly: 32 (temp), 33 (humidity), 35 (precip), 36 (rad), 46 (windspeed), 47 (winddir)}
#'   \item{daily: 1000:1002 (temp), 1100:1102 (humidity), 1300 (precip), 1400 (rad), 1505 (windspeed), 1511(winddir)}
#'   \item{monthly: 2000:2004 (temp), 2100:2104 (humidity), 2300 (precip), 2400 (rad), 2505 (windspeed), 2511(winddir)}
#'   \item{yearly: 3000:3004 (temp), 3100:3104 (humidity), 3300 (precip), 3400 (rad), 3505 (windspeed), 3511(winddir)}
#' }
#'
#' @param api_options Option list as generated by \link{\code{meteocat_options}}
#'
#' @noRd
.create_meteocat_path <- function(api_options) {

  # we need the resolution to create the corresponding path
  resolution <- api_options$resolution

  # depending on resolution, the variables list is different
  variables_list <- switch(
    api_options$resolution,
    'instant' = c(32, 33, 35, 36, 46, 47),
    'hourly' = c(32, 33, 35, 36, 46, 47),
    'daily' = c(1000:1002, 1100:1102, 1300, 1400, 1505, 1511),
    'monthly' = c(2000:2004, 2100:2104, 2300, 2400, 2505, 2511),
    'yearly' = c(3000:3004, 3100:3104, 3300, 3400, 3505, 3511)
  )

  # now the path vectors for the resolutions
  paths_resolution <- switch(
    api_options$resolution,
    'instant' = purrr::map(
      variables_list,
      function(variable) { c('xema', 'v1', 'variables', 'mesurades', variable, 'ultimes') }
    ),
    'hourly' = purrr::map(
      variables_list,
      function(variable) {
        c(
          'xema', 'v1', 'variables', 'mesurades', variable, lubridate::year(api_options$start_date),
          lubridate::month(api_options$start_date), lubridate::day(api_options$start_date)
        )
      }
    ),
    # for daily and monthly, dates are query parameters not path ones.
    'daily' = purrr::map(
      variables_list,
      function(variable) { c('xema', 'v1', 'variables', 'estadistics', 'diaris', variable) }
    ),
    'monthly' = purrr::map(
      variables_list,
      function(variable) { c('xema', 'v1', 'variables', 'estadistics', 'mensuals', variable) }
    ),
    'yearly' = purrr::map(
      variables_list,
      function(variable) { c('xema', 'v1', 'variables', 'estadistics', 'anuals', variable) }
    ),
    list()
  )

  # not recognised resolution
  if (length(paths_resolution) < 1) {
    stop(
      api_options$resolution,
      " is not a valid temporal resolution for MeteoCat.\nPlease see meteocat_options help for more information"
    )
  }

  return(paths_resolution)
}

#' Create the query element for MeteoCat API
#'
#' Query string for MeteoCat API to use with httr::GET
#'
#' MeteoCat needs dates for daily and monthly resolutions as query parameters (broken down in year and month).
#'
#' @param api_options Option list as generated by \link{\code{meteocat_options}}
#'
#' @noRd
.create_meteocat_query <- function(api_options) {

  # dates supplied must be broken down and stored in year and month values to create the query parameters
  year_query_par <- glue::glue("any={lubridate::year(api_options$start_date)}")
  month_query_par <- glue::glue("&mes={lubridate::month(api_options$start_date)}")

  dates_query_string <- switch(
    api_options$resolution,
    'daily' = glue::glue(year_query_par, month_query_par),
    'monthly' = year_query_par,
    character(0)
  )

  return(dates_query_string)
}

#' Get info for the meteocat stations
#'
#' Get info for the meteocat stations
#'
#' @noRd

.get_info_meteocat <- function(api_options) {

  # GET parts needed --------------------------------------------------------------------------------------
  # meteocat stamp function
  meteocat_stamp <- lubridate::stamp("2020-12-25Z", orders = "YOmd", quiet = TRUE)
  # path
  path_resolution <- c('xema', 'v1', 'estacions', 'metadades')
  # query
  query_resolution <- c(glue::glue("estat=ope&data={meteocat_stamp(api_options$start_date)}"))

  # api response
  # api_response <- httr::GET(
  #   "https://api.meteo.cat",
  #   httr::add_headers(`x-api-key` = api_options$api_key),
  #   path = path_resolution,
  #   query = query_resolution,
  #   httr::user_agent('https://github.com/emf-creaf/meteospain')
  # )

  # Status check ------------------------------------------------------------------------------------------
  api_status_check <- .check_status_meteocat(
    "https://api.meteo.cat",
    httr::add_headers(`x-api-key` = api_options$api_key),
    path = path_resolution,
    query = query_resolution,
    httr::user_agent('https://github.com/emf-creaf/meteospain')
  )

  if (api_status_check$status != 'OK') {
    # if api request limit reached, do a recursive call to the function after 60 seconds
    if (api_status_check$code == 429) {
      message(copyright_style(api_status_check$message))
      Sys.sleep(60)
      return(.get_info_meteocat(api_options))
    } else {
      stop(api_status_check$code, ':\n', api_status_check$message)
    }
  }

  # Data --------------------------------------------------------------------------------------------------
  # Meteocat returns a data frame, but some variables are data frames themselves. We need to work on that
  response_content <- api_status_check$content

  coords_df <- response_content[['coordenades']]
  province_df <- response_content[['provincia']]['nom'] %>%
    dplyr::rename(station_province = .data$nom)

  response_content %>%
    dplyr::as_tibble() %>%
    dplyr::select(
      !dplyr::any_of(c(
        'coordenades', 'municipi', 'comarca', 'provincia',
        'xarxa', 'estats', 'tipus', 'emplacament'
      ))
    ) %>%
    dplyr::bind_cols(coords_df, province_df) %>%
    dplyr::select(
      station_id = .data$codi, station_name = .data$nom, station_province,
      altitude = .data$altitud, .data$longitud, .data$latitud
    ) %>%
    dplyr::mutate(
      altitude = units::set_units(.data$altitude, 'm')
    ) %>%
    sf::st_as_sf(coords = c('longitud', 'latitud'), crs = 4326)

}
